/**
 * ChittyChat Project Orchestration Service
 * Manages Claude sessions across machines with conflict detection
 * Part of ChittyChat unified platform
 *
 * Architecture:
 * - READS existing ~/.claude/projects/<project>/*.jsonl files (auto-generated by Claude)
 * - CONSOLIDATES todos, sessions, context across multiple sessions
 * - SYNCS consolidated state to user's chittychat-data GitHub repo
 * - Does NOT create new files in ~/.claude/ - only reads and consolidates
 * - On new session start, LOADS consolidated state from GitHub
 */

import { Octokit } from '@octokit/rest';
import { LocalConsolidator } from './local-consolidator.js';

/**
 * Project Orchestrator - manages session coordination
 */
export class ProjectOrchestrator {
  constructor(env) {
    this.env = env;
    this.github = env.GITHUB_TOKEN ? new Octokit({ auth: env.GITHUB_TOKEN }) : null;
    // User's data repo config (separate from code repos)
    this.dataRepoOwner = env.DATA_REPO_OWNER || env.GITHUB_OWNER || 'user';
    this.dataRepoName = env.DATA_REPO_NAME || 'chittychat-data';
    // Local consolidator for scanning Claude files
    this.localConsolidator = new LocalConsolidator();
  }

  /**
   * Consolidate local project and sync to GitHub
   * 1. Merges multiple session files into one consolidated file
   * 2. Archives old session files
   * 3. Syncs consolidated state to GitHub
   */
  async consolidateAndSync(projectName) {
    try {
      // Step 1: Merge and archive local session files
      const mergeResult = await this.localConsolidator.consolidateAndMerge(projectName);

      if (!mergeResult.success) {
        // If merge fails but we have consolidated state, continue with sync
        if (mergeResult.message && mergeResult.message.includes('Only one session file')) {
          // Only one file, get its consolidated state
          const consolidatedState =
            await this.localConsolidator.getProjectConsolidatedState(projectName);

          if (consolidatedState) {
            const syncResult = await this.syncConsolidatedState(projectName, consolidatedState);
            return {
              success: syncResult.success,
              projectName,
              mergeResult,
              consolidatedState,
              syncResult,
            };
          }
        }
        return mergeResult;
      }

      // Step 2: Sync consolidated state to GitHub
      const consolidatedState = mergeResult.consolidatedState;
      const syncResult = await this.syncConsolidatedState(projectName, consolidatedState);

      return {
        success: syncResult.success,
        projectName,
        mergeResult,
        consolidatedState,
        syncResult,
        summary: {
          originalFiles: mergeResult.originalFiles,
          mergedEntries: mergeResult.mergedEntries,
          archivedFiles: mergeResult.archived?.count || 0,
          consolidatedFile: mergeResult.consolidated?.filePath,
          syncedToGitHub: syncResult.success,
        },
      };
    } catch (error) {
      console.error('Error consolidating and syncing:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get consolidated state from GitHub (for session initialization)
   */
  async getConsolidatedStateFromGitHub(projectName) {
    if (!this.github) {
      return { success: false, error: 'GitHub not configured' };
    }

    try {
      const owner = this.dataRepoOwner;
      const repo = this.dataRepoName;
      const filePath = `consolidated/${projectName}/state.json`;

      const { data: file } = await this.github.repos.getContent({
        owner,
        repo,
        path: filePath,
      });

      const content = Buffer.from(file.content, 'base64').toString();
      const state = JSON.parse(content);

      return { success: true, state, fromGitHub: true };
    } catch (error) {
      if (error.status === 404) {
        return { success: false, error: 'Project not yet synced to GitHub' };
      }
      console.error('Error fetching consolidated state from GitHub:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get active sessions for a project
   */
  async getActiveSessions(projectId) {
    try {
      const sessions = await this.env.PLATFORM_KV?.get(`sessions:${projectId}`, { type: 'json' });
      return sessions || [];
    } catch (error) {
      console.error('Error fetching sessions:', error);
      return [];
    }
  }

  /**
   * Register a new session
   */
  async registerSession(sessionData) {
    const { projectId, sessionId, machineId, platform, timestamp } = sessionData;

    try {
      // Get existing sessions
      const sessions = await this.getActiveSessions(projectId);

      // Add new session
      const newSession = {
        sessionId,
        machineId,
        platform,
        timestamp: timestamp || new Date().toISOString(),
        active: true,
        lastActivity: new Date().toISOString(),
      };

      sessions.push(newSession);

      // Store updated sessions
      await this.env.PLATFORM_KV?.put(
        `sessions:${projectId}`,
        JSON.stringify(sessions),
        { expirationTtl: 86400 } // 24 hours
      );

      return { success: true, sessionId, sessions: sessions.length };
    } catch (error) {
      console.error('Error registering session:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Detect session conflicts
   */
  async detectConflicts(projectId, fileOperation) {
    try {
      const sessions = await this.getActiveSessions(projectId);
      const activeSessions = sessions.filter((s) => s.active);

      // Conflict if multiple sessions working on same file
      if (activeSessions.length > 1 && fileOperation) {
        const { filePath, operation } = fileOperation;

        return {
          hasConflict: true,
          sessions: activeSessions,
          fileConflict: {
            filePath,
            operation,
            sessionCount: activeSessions.length,
          },
        };
      }

      return { hasConflict: false, sessions: activeSessions };
    } catch (error) {
      console.error('Error detecting conflicts:', error);
      return { hasConflict: false, error: error.message };
    }
  }

  /**
   * Sync consolidated state to user's chittychat-data repo
   * This stores CONSOLIDATED METADATA, not actual code files or original session files
   */
  async syncConsolidatedState(projectName, consolidatedState) {
    if (!this.github) {
      return { success: false, error: 'GitHub not configured' };
    }

    try {
      const owner = this.dataRepoOwner;
      const repo = this.dataRepoName;

      // Data structure for chittychat-data repo:
      // - consolidated/ - Consolidated project states
      // - projects/ - Project metadata (references to actual code repos)
      // - todos/ - Deduplicated task lists
      // - history/ - Session history

      const dataPayload = {
        projectName,
        ...consolidatedState,
        dataType: 'consolidated-state',
        syncedAt: new Date().toISOString(),
      };

      // Create or update consolidated state file
      const filePath = `consolidated/${projectName}/state.json`;

      try {
        // Try to get existing file
        const { data: existingFile } = await this.github.repos.getContent({
          owner,
          repo,
          path: filePath,
        });

        // Update existing file
        await this.github.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: filePath,
          message: `Update consolidated state: ${projectName}`,
          content: Buffer.from(JSON.stringify(dataPayload, null, 2)).toString('base64'),
          sha: existingFile.sha,
        });
      } catch (error) {
        if (error.status === 404) {
          // Create new file
          await this.github.repos.createOrUpdateFileContents({
            owner,
            repo,
            path: filePath,
            message: `Create consolidated state: ${projectName}`,
            content: Buffer.from(JSON.stringify(dataPayload, null, 2)).toString('base64'),
          });
        } else {
          throw error;
        }
      }

      // Also sync just the todos separately for easy access
      const todosPath = `todos/${projectName}/todos.json`;
      const todosPayload = {
        projectName,
        todos: consolidatedState.consolidatedTodos,
        updatedAt: new Date().toISOString(),
      };

      try {
        const { data: existingTodos } = await this.github.repos.getContent({
          owner,
          repo,
          path: todosPath,
        });

        await this.github.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: todosPath,
          message: `Update todos: ${projectName}`,
          content: Buffer.from(JSON.stringify(todosPayload, null, 2)).toString('base64'),
          sha: existingTodos.sha,
        });
      } catch (error) {
        if (error.status === 404) {
          await this.github.repos.createOrUpdateFileContents({
            owner,
            repo,
            path: todosPath,
            message: `Create todos: ${projectName}`,
            content: Buffer.from(JSON.stringify(todosPayload, null, 2)).toString('base64'),
          });
        }
      }

      return { success: true, synced: true, dataRepo: `${owner}/${repo}`, filePath };
    } catch (error) {
      console.error('Error syncing consolidated state:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get project references from user's data repo
   */
  async getProjectReferences(userId) {
    if (!this.github) {
      return { projects: [], error: 'GitHub not configured' };
    }

    try {
      const owner = this.dataRepoOwner;
      const repo = this.dataRepoName;

      // List projects directory
      const { data: projects } = await this.github.repos.getContent({
        owner,
        repo,
        path: 'projects',
      });

      const projectRefs = await Promise.all(
        projects
          .filter((p) => p.type === 'file' && p.name.endsWith('.json'))
          .map(async (p) => {
            const { data: file } = await this.github.repos.getContent({
              owner,
              repo,
              path: p.path,
            });
            const content = Buffer.from(file.content, 'base64').toString();
            return JSON.parse(content);
          })
      );

      return { projects: projectRefs, dataRepo: `${owner}/${repo}` };
    } catch (error) {
      console.error('Error fetching project references:', error);
      return { projects: [], error: error.message };
    }
  }

  /**
   * End a session
   */
  async endSession(projectId, sessionId) {
    try {
      const sessions = await this.getActiveSessions(projectId);
      const updated = sessions.map((s) =>
        s.sessionId === sessionId ? { ...s, active: false, endedAt: new Date().toISOString() } : s
      );

      await this.env.PLATFORM_KV?.put(`sessions:${projectId}`, JSON.stringify(updated));

      return { success: true, sessionId };
    } catch (error) {
      console.error('Error ending session:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get project status
   */
  async getProjectStatus(projectId) {
    try {
      const sessions = await this.getActiveSessions(projectId);
      const activeSessions = sessions.filter((s) => s.active);

      return {
        projectId,
        totalSessions: sessions.length,
        activeSessions: activeSessions.length,
        sessions: activeSessions,
        lastActivity: sessions.length > 0 ? sessions[sessions.length - 1].lastActivity : null,
      };
    } catch (error) {
      console.error('Error getting project status:', error);
      return { error: error.message };
    }
  }
}

/**
 * Handle project orchestration requests
 */
export async function handleProjectOrchestration(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const pathname = url.pathname;

  const orchestrator = new ProjectOrchestrator(env);

  // Health check
  if (pathname === '/health') {
    return new Response(
      JSON.stringify({
        status: 'healthy',
        service: 'ChittyChat Project Orchestration',
        version: '1.0.0',
        features: ['session-management', 'conflict-detection', 'github-sync'],
      }),
      { headers: { 'Content-Type': 'application/json' } }
    );
  }

  // API endpoints
  try {
    const method = request.method;

    // GET /api/sessions/:projectId - Get active sessions
    if (method === 'GET' && pathname.match(/^\/api\/sessions\/(.+)$/)) {
      const projectId = pathname.split('/').pop();
      const sessions = await orchestrator.getActiveSessions(projectId);
      return new Response(JSON.stringify({ projectId, sessions }), {
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // POST /api/sessions/register - Register new session
    if (method === 'POST' && pathname === '/api/sessions/register') {
      const sessionData = await request.json();
      const result = await orchestrator.registerSession(sessionData);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // POST /api/sessions/conflicts - Check for conflicts
    if (method === 'POST' && pathname === '/api/sessions/conflicts') {
      const { projectId, fileOperation } = await request.json();
      const result = await orchestrator.detectConflicts(projectId, fileOperation);
      return new Response(JSON.stringify(result), {
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // POST /api/consolidate/:projectName - Consolidate local sessions and sync to GitHub
    if (method === 'POST' && pathname.match(/^\/api\/consolidate\/(.+)$/)) {
      const projectName = decodeURIComponent(pathname.split('/').pop());
      const result = await orchestrator.consolidateAndSync(projectName);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // GET /api/consolidated/:projectName - Get consolidated state from GitHub
    if (method === 'GET' && pathname.match(/^\/api\/consolidated\/(.+)$/)) {
      const projectName = decodeURIComponent(pathname.split('/').pop());
      const result = await orchestrator.getConsolidatedStateFromGitHub(projectName);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 404,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // GET /api/projects - Get local initialized projects
    if (method === 'GET' && pathname === '/api/projects') {
      const projects = await orchestrator.localConsolidator.getProjectDirectories();
      const initialized = [];

      for (const project of projects) {
        const isInit = await orchestrator.localConsolidator.isProjectInitialized(project.name);
        if (isInit) {
          initialized.push(project);
        }
      }

      return new Response(JSON.stringify({ projects: initialized, count: initialized.length }), {
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // DELETE /api/sessions/:projectId/:sessionId - End session
    if (method === 'DELETE' && pathname.match(/^\/api\/sessions\/(.+)\/(.+)$/)) {
      const [, projectId, sessionId] = pathname.split('/').filter(Boolean);
      const result = await orchestrator.endSession(
        projectId.replace('api/sessions/', ''),
        sessionId
      );
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // GET /api/status/:projectId - Get project status
    if (method === 'GET' && pathname.match(/^\/api\/status\/(.+)$/)) {
      const projectId = pathname.split('/').pop();
      const status = await orchestrator.getProjectStatus(projectId);
      return new Response(JSON.stringify(status), {
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Not found
    return new Response(
      JSON.stringify({
        error: 'Not Found',
        message: 'Project orchestration endpoint not found',
        availableEndpoints: [
          'GET /api/sessions/:projectId',
          'POST /api/sessions/register',
          'POST /api/sessions/conflicts',
          'POST /api/sessions/sync',
          'DELETE /api/sessions/:projectId/:sessionId',
          'GET /api/status/:projectId',
        ],
      }),
      { status: 404, headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({
        error: 'Internal Error',
        message: error.message,
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
