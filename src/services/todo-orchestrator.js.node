/**
 * Todo Orchestration Service
 * Bidirectional sync between:
 * 1. Consolidated todos (chittychat-data GitHub repo) - SOURCE OF TRUTH
 * 2. Claude session todos (~/.claude/tasks/<sessionId>.json) - Auto-generated
 * 3. Project todo files (/-/chittychat/todos.json) - Optional project-local
 *
 * Flow:
 * - Consolidated → Session: Load todos on session start
 * - Session → Consolidated: Sync on TodoWrite, checkpoint, cron
 * - Consolidated → Project folder: Write to /-/project/todos.json
 * - Project folder → Consolidated: Read on consolidation
 */

import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';

export class TodoOrchestrator {
  constructor(env) {
    this.env = env;
    this.claudeTodosDir = path.join(os.homedir(), '.claude', 'todos');
    this.workingDir = process.env.PWD || process.cwd();
  }

  /**
   * Get Claude's auto-generated todo file for current session
   * Claude creates: ~/.claude/todos/<sessionId>-agent-<sessionId>.json
   */
  async getClaudeSessionTodos(sessionId) {
    try {
      const todoFile = path.join(this.claudeTodosDir, `${sessionId}-agent-${sessionId}.json`);
      const content = await fs.readFile(todoFile, 'utf-8');
      const data = JSON.parse(content);
      // Claude stores as array directly
      return Array.isArray(data) ? data : [];
    } catch (error) {
      // File doesn't exist yet or not readable
      return [];
    }
  }

  /**
   * Write todos to Claude's session todo file
   * This updates what Claude sees in the sidebar
   */
  async writeClaudeSessionTodos(sessionId, todos) {
    try {
      await fs.mkdir(this.claudeTodosDir, { recursive: true });
      const todoFile = path.join(this.claudeTodosDir, `${sessionId}-agent-${sessionId}.json`);

      // Claude expects array of todo objects directly, not wrapped
      const todoArray = todos.map((todo) => ({
        content: todo.content,
        status: todo.status,
        activeForm: todo.activeForm,
        // Optional metadata for tracking
        projectId: todo.projectId,
        addedBy: todo.addedBy,
        syncedFrom: 'consolidated',
        syncedAt: new Date().toISOString(),
      }));

      await fs.writeFile(todoFile, JSON.stringify(todoArray, null, 2), 'utf-8');
      return { success: true, todosWritten: todos.length };
    } catch (error) {
      console.error('Error writing Claude session todos:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get project-local todos from working directory
   * Optional: /-/chittychat/todos.json
   */
  async getProjectLocalTodos(projectId) {
    try {
      // Project ID like "-/chittychat" → directory "chittychat"
      const projectDir = projectId.replace('-/', '');
      const todoFile = path.join(this.workingDir, projectDir, 'todos.json');

      const content = await fs.readFile(todoFile, 'utf-8');
      const data = JSON.parse(content);
      return data.todos || [];
    } catch (error) {
      // File doesn't exist - normal for projects without local todos
      return [];
    }
  }

  /**
   * Write todos to project-local file
   * Creates: /-/chittychat/todos.json
   */
  async writeProjectLocalTodos(projectId, todos) {
    try {
      const projectDir = projectId.replace('-/', '');
      const projectPath = path.join(this.workingDir, projectDir);
      await fs.mkdir(projectPath, { recursive: true });

      const todoFile = path.join(projectPath, 'todos.json');

      const todoData = {
        projectId,
        todos: todos.map((todo) => ({
          content: todo.content,
          status: todo.status,
          activeForm: todo.activeForm,
          addedBy: todo.addedBy,
          updatedBy: todo.updatedBy,
          addedAt: todo.addedAt,
          updatedAt: todo.updatedAt,
        })),
        lastSync: new Date().toISOString(),
        syncedFrom: 'consolidated',
      };

      await fs.writeFile(todoFile, JSON.stringify(todoData, null, 2), 'utf-8');
      return { success: true, file: todoFile, todosWritten: todos.length };
    } catch (error) {
      console.error('Error writing project local todos:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Orchestrate todo assignment across active sessions
   * Distributes work based on:
   * - Session machine/platform
   * - Current session activity
   * - Todo priority/status
   */
  async orchestrateTodoAssignment(projectId, sessions, consolidatedTodos) {
    const assignments = {};

    // Get active sessions
    const activeSessions = sessions.filter((s) => s.active);

    if (activeSessions.length === 0) {
      // No active sessions - all todos remain unassigned
      return {
        assignments: {},
        unassigned: consolidatedTodos,
      };
    }

    // Strategy 1: Keep in-progress todos with original session
    const inProgressTodos = consolidatedTodos.filter((t) => t.status === 'in_progress');
    for (const todo of inProgressTodos) {
      const ownerSession = activeSessions.find((s) => s.sessionId === todo.addedBy);
      if (ownerSession) {
        if (!assignments[ownerSession.sessionId]) {
          assignments[ownerSession.sessionId] = [];
        }
        assignments[ownerSession.sessionId].push(todo);
      }
    }

    // Strategy 2: Distribute pending todos across active sessions
    const pendingTodos = consolidatedTodos.filter((t) => t.status === 'pending');
    const assignedTodoIds = new Set(
      Object.values(assignments)
        .flat()
        .map((t) => t.content)
    );
    const unassignedPending = pendingTodos.filter((t) => !assignedTodoIds.has(t.content));

    // Round-robin distribution
    unassignedPending.forEach((todo, index) => {
      const sessionIndex = index % activeSessions.length;
      const session = activeSessions[sessionIndex];

      if (!assignments[session.sessionId]) {
        assignments[session.sessionId] = [];
      }
      assignments[session.sessionId].push(todo);
    });

    // Strategy 3: Completed todos visible to all (for context)
    const completedTodos = consolidatedTodos.filter((t) => t.status === 'completed');

    return {
      assignments,
      completedTodos,
      unassigned: consolidatedTodos.filter(
        (t) =>
          !Object.values(assignments)
            .flat()
            .some((assigned) => assigned.content === t.content) && t.status !== 'completed'
      ),
    };
  }

  /**
   * Sync consolidated todos to all active session files
   * This updates Claude's sidebar for each active session
   */
  async syncConsolidatedToSessions(projectId, consolidatedTodos, sessions) {
    const results = {
      success: true,
      sessionsUpdated: [],
      errors: [],
    };

    // Get todo assignments
    const { assignments, completedTodos } = await this.orchestrateTodoAssignment(
      projectId,
      sessions,
      consolidatedTodos
    );

    // Write to each active session's task file
    for (const session of sessions.filter((s) => s.active)) {
      const sessionId = session.sessionId;

      // Session gets its assigned todos + completed todos (for context)
      const sessionTodos = [
        ...(assignments[sessionId] || []),
        ...completedTodos.slice(0, 5), // Last 5 completed for context
      ];

      const result = await this.writeClaudeSessionTodos(sessionId, sessionTodos);

      if (result.success) {
        results.sessionsUpdated.push({
          sessionId,
          machineId: session.machineId,
          todosAssigned: assignments[sessionId]?.length || 0,
          completedVisible: Math.min(completedTodos.length, 5),
        });
      } else {
        results.errors.push({
          sessionId,
          error: result.error,
        });
      }
    }

    if (results.errors.length > 0) {
      results.success = false;
    }

    return results;
  }

  /**
   * Sync consolidated todos to project folder
   * Creates: /-/chittychat/todos.json
   */
  async syncConsolidatedToProjectFolder(projectId, consolidatedTodos) {
    return await this.writeProjectLocalTodos(projectId, consolidatedTodos);
  }

  /**
   * Full orchestration: Consolidated → Sessions + Project folder
   */
  async orchestrateFromConsolidated(projectId, consolidatedTodos, sessions) {
    const results = {
      success: true,
      sessionsSync: null,
      projectFolderSync: null,
    };

    // Sync to active session files
    results.sessionsSync = await this.syncConsolidatedToSessions(
      projectId,
      consolidatedTodos,
      sessions
    );

    // Sync to project folder
    results.projectFolderSync = await this.syncConsolidatedToProjectFolder(
      projectId,
      consolidatedTodos
    );

    results.success = results.sessionsSync.success && results.projectFolderSync.success;

    return results;
  }

  /**
   * Guide sessions based on consolidated todos
   * Returns guidance for each active session
   */
  async generateSessionGuidance(projectId, consolidatedTodos, sessions) {
    const { assignments, completedTodos, unassigned } = await this.orchestrateTodoAssignment(
      projectId,
      sessions,
      consolidatedTodos
    );

    const guidance = {};

    for (const session of sessions.filter((s) => s.active)) {
      const sessionId = session.sessionId;
      const assignedTodos = assignments[sessionId] || [];

      guidance[sessionId] = {
        machineId: session.machineId,
        platform: session.platform,
        assigned: assignedTodos,
        assignedCount: assignedTodos.length,
        inProgress: assignedTodos.filter((t) => t.status === 'in_progress').length,
        pending: assignedTodos.filter((t) => t.status === 'pending').length,
        completedVisible: completedTodos.slice(0, 5),
        suggestions: this.generateSuggestions(assignedTodos, completedTodos),
        nextAction: this.determineNextAction(assignedTodos),
      };
    }

    return {
      guidance,
      unassigned,
      summary: {
        totalActiveSessions: sessions.filter((s) => s.active).length,
        totalTodos: consolidatedTodos.length,
        assigned: Object.values(assignments).flat().length,
        unassigned: unassigned.length,
        completed: completedTodos.length,
      },
    };
  }

  /**
   * Generate suggestions for session based on todos
   */
  generateSuggestions(assignedTodos, completedTodos) {
    const suggestions = [];

    const inProgress = assignedTodos.filter((t) => t.status === 'in_progress');
    if (inProgress.length > 0) {
      suggestions.push(`Continue work on: "${inProgress[0].content}"`);
    }

    const pending = assignedTodos.filter((t) => t.status === 'pending');
    if (pending.length > 0 && inProgress.length === 0) {
      suggestions.push(`Start next task: "${pending[0].content}"`);
    }

    if (assignedTodos.length === 0 && completedTodos.length > 0) {
      suggestions.push('All assigned tasks complete! Check for new work.');
    }

    return suggestions;
  }

  /**
   * Determine next action for session
   */
  determineNextAction(assignedTodos) {
    const inProgress = assignedTodos.find((t) => t.status === 'in_progress');
    if (inProgress) {
      return {
        action: 'continue',
        todo: inProgress,
      };
    }

    const pending = assignedTodos.find((t) => t.status === 'pending');
    if (pending) {
      return {
        action: 'start',
        todo: pending,
      };
    }

    return {
      action: 'wait',
      message: 'No todos assigned or all complete',
    };
  }
}

/**
 * Handle todo orchestration requests (for Worker integration)
 */
export async function handleTodoOrchestration(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const pathname = url.pathname;
  const method = request.method;

  const orchestrator = new TodoOrchestrator(env);

  // POST /api/orchestrate/todos/:projectId - Orchestrate todos to sessions
  if (method === 'POST' && pathname.match(/^\/api\/orchestrate\/todos\/(.+)$/)) {
    const projectId = decodeURIComponent(pathname.split('/').pop());

    const { consolidatedTodos, sessions } = await request.json();

    const result = await orchestrator.orchestrateFromConsolidated(
      projectId,
      consolidatedTodos,
      sessions
    );

    return new Response(JSON.stringify(result), {
      status: result.success ? 200 : 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  // GET /api/orchestrate/guidance/:projectId - Get guidance for sessions
  if (method === 'GET' && pathname.match(/^\/api\/orchestrate\/guidance\/(.+)$/)) {
    const projectId = decodeURIComponent(pathname.split('/').pop());

    // Get consolidated todos and active sessions
    const consolidatedTodos = await env.PLATFORM_KV.get(`sync:todos:${projectId}`, {
      type: 'json',
    });
    const sessions = await env.PLATFORM_KV.get(`sessions:${projectId}`, { type: 'json' });

    if (!consolidatedTodos || !sessions) {
      return new Response(
        JSON.stringify({
          error: 'Project not found or no todos/sessions available',
        }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const guidance = await orchestrator.generateSessionGuidance(
      projectId,
      consolidatedTodos.todos,
      sessions
    );

    return new Response(JSON.stringify(guidance), {
      headers: { 'Content-Type': 'application/json' },
    });
  }

  return new Response(
    JSON.stringify({
      error: 'Not Found',
      availableEndpoints: [
        'POST /api/orchestrate/todos/:projectId',
        'GET /api/orchestrate/guidance/:projectId',
      ],
    }),
    { status: 404, headers: { 'Content-Type': 'application/json' } }
  );
}
