/**
 * ChittyLedger Integration Service
 * Bridges ChittyLedger (Notion Database) with ChittyOS-Data (Sovereign Storage)
 * Creates tamper-proof evidence management with AI processing
 */

export class ChittyLedgerIntegration {
  constructor(env) {
    this.env = env;
    this.storage = env.PLATFORM_STORAGE; // R2 Bucket
    this.cache = env.PLATFORM_CACHE; // KV Namespace
    this.ai = env.AI; // Workers AI
    this.notionToken = env.NOTION_TOKEN;
    this.evidenceDbId = env.NOTION_EVIDENCE_DB;
    this.casesDbId = env.NOTION_CASES_DB;
  }

  /**
   * Evidence ID → File Hash Mapping System
   * Creates bidirectional mapping between ChittyLedger and ChittyOS-Data
   */
  async mapEvidenceToHash(evidenceId, fileHash, metadata = {}) {
    const mappingKey = `evidence:${evidenceId}`;
    const hashKey = `hash:${fileHash}`;

    const mappingData = {
      evidenceId,
      fileHash,
      artifactId: `ART-${fileHash.substring(0, 12)}`,
      timestamp: new Date().toISOString(),
      chainStatus: 'pending',
      ...metadata
    };

    // Store bidirectional mapping in KV
    await Promise.all([
      this.cache.put(mappingKey, JSON.stringify(mappingData)),
      this.cache.put(hashKey, JSON.stringify(mappingData)),
      this.cache.put(`mapping:${evidenceId}:${fileHash}`, JSON.stringify({
        verified: true,
        createdAt: mappingData.timestamp
      }))
    ]);

    return mappingData;
  }

  /**
   * Upload Evidence File with Content Addressing
   * Stores file immutably in R2 with SHA-256 hash as key
   */
  async uploadEvidenceFile(fileBuffer, fileName, evidenceId) {
    // Calculate SHA-256 hash for content addressing
    const hashBuffer = await crypto.subtle.digest('SHA-256', fileBuffer);
    const fileHash = Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');

    // Generate storage key: evidence/{hash}
    const storageKey = `evidence/${fileHash}`;

    // Store file in R2 with metadata
    await this.storage.put(storageKey, fileBuffer, {
      httpMetadata: {
        contentType: this.detectContentType(fileName),
        contentDisposition: `attachment; filename="${fileName}"`
      },
      customMetadata: {
        evidenceId,
        originalFileName: fileName,
        uploadedAt: new Date().toISOString(),
        hash: fileHash,
        size: fileBuffer.byteLength.toString()
      }
    });

    // Create evidence mapping
    await this.mapEvidenceToHash(evidenceId, fileHash, {
      fileName,
      size: fileBuffer.byteLength,
      contentType: this.detectContentType(fileName)
    });

    return {
      fileHash,
      storageKey,
      artifactId: `ART-${fileHash.substring(0, 12)}`,
      url: `https://storage.chitty.cc/evidence/${fileHash}`
    };
  }

  /**
   * Chain Status Integration with Soft/Hard Minting Support
   * Syncs evidence status between ChittyLedger and ChittyOS-Data
   * Soft Mint = Off-chain verification (fast, free, reversible)
   * Hard Mint = On-chain blockchain recording (permanent, costs gas, immutable)
   */
  async updateChainStatus(evidenceId, status, metadata = {}) {
    const validStatuses = ['pending', 'soft_minted', 'hard_minted', 'rejected', 'verified', 'archived'];

    if (!validStatuses.includes(status)) {
      throw new Error(`Invalid status: ${status}. Must be one of: ${validStatuses.join(', ')}`);
    }

    const mappingKey = `evidence:${evidenceId}`;
    const existingMapping = await this.cache.get(mappingKey);

    if (!existingMapping) {
      throw new Error(`Evidence mapping not found for ID: ${evidenceId}`);
    }

    const mapping = JSON.parse(existingMapping);
    mapping.chainStatus = status;
    mapping.lastUpdated = new Date().toISOString();
    mapping.statusMetadata = metadata;

    // Update KV mapping
    await this.cache.put(mappingKey, JSON.stringify(mapping));

    // Update Notion database
    await this.updateNotionEvidenceStatus(evidenceId, status, metadata);

    // Log status change in audit trail
    await this.logAuditEvent('status_change', {
      evidenceId,
      previousStatus: mapping.chainStatus,
      newStatus: status,
      metadata
    });

    return mapping;
  }

  /**
   * AI Processing Bridge
   * Processes evidence files with AI and syncs metadata to ChittyLedger
   */
  async processEvidenceWithAI(evidenceId, fileHash) {
    try {
      // Retrieve file from storage
      const storageKey = `evidence/${fileHash}`;
      const file = await this.storage.get(storageKey);

      if (!file) {
        throw new Error(`File not found for hash: ${fileHash}`);
      }

      const fileBuffer = await file.arrayBuffer();
      const fileText = await this.extractTextFromFile(fileBuffer, file.httpMetadata.contentType);

      // AI analysis for legal relevance
      const aiAnalysis = await this.ai.run('@cf/meta/llama-3.1-8b-instruct', {
        messages: [
          {
            role: 'system',
            content: 'You are a legal document analysis AI. Analyze the provided document and extract key information for legal evidence management.'
          },
          {
            role: 'user',
            content: `Analyze this legal document and provide:
1. Evidence Type Classification
2. Key Legal Facts
3. Confidence Score (0-100)
4. Relevance Assessment
5. Recommended Chain of Custody Actions

Document content:
${fileText.substring(0, 4000)}`
          }
        ]
      });

      const aiMetadata = {
        evidenceType: this.extractEvidenceType(aiAnalysis.response),
        legalFacts: this.extractLegalFacts(aiAnalysis.response),
        confidenceScore: this.extractConfidenceScore(aiAnalysis.response),
        relevanceAssessment: this.extractRelevanceAssessment(aiAnalysis.response),
        aiProcessedAt: new Date().toISOString(),
        aiModel: '@cf/meta/llama-3.1-8b-instruct'
      };

      // Update ChittyLedger with AI metadata
      await this.syncAIMetadataToNotion(evidenceId, aiMetadata);

      // Update local mapping
      const mappingKey = `evidence:${evidenceId}`;
      const mapping = JSON.parse(await this.cache.get(mappingKey));
      mapping.aiMetadata = aiMetadata;
      await this.cache.put(mappingKey, JSON.stringify(mapping));

      return aiMetadata;

    } catch (error) {
      console.error('AI processing failed:', error);
      throw new Error(`AI processing failed: ${error.message}`);
    }
  }

  /**
   * Soft Mint (Off-Chain)
   * Quick verification and storage without blockchain costs
   * Suitable for most evidence that doesn't require immutable proof
   */
  async softMint(evidenceId, metadata = {}) {
    try {
      // Get existing evidence mapping
      const mappingKey = `evidence:${evidenceId}`;
      const existingMapping = await this.cache.get(mappingKey);

      if (!existingMapping) {
        throw new Error(`Evidence not found: ${evidenceId}`);
      }

      const mapping = JSON.parse(existingMapping);

      // Create soft mint record (off-chain verification)
      const softMintRecord = {
        evidenceId,
        fileHash: mapping.fileHash,
        mintType: 'soft',
        verificationLevel: 'off-chain',
        timestamp: new Date().toISOString(),
        metadata: {
          ...metadata,
          verified: true,
          verificationMethod: 'ChittyOS Internal Verification',
          storageLocation: 'ChittyOS-Data R2',
          reversible: true,
          gasCost: 0
        }
      };

      // Store in KV (not blockchain)
      const softMintKey = `soft-mint:${evidenceId}`;
      await this.cache.put(softMintKey, JSON.stringify(softMintRecord), {
        expirationTtl: 60 * 60 * 24 * 365 // 1 year TTL for soft mints
      });

      // Update status to soft minted
      await this.updateChainStatus(evidenceId, 'soft_minted', {
        mintType: 'soft',
        record: softMintRecord
      });

      // Add custody event
      await this.addCustodyEvent(
        evidenceId,
        'Soft Minted (Off-Chain)',
        'ChittyOS System',
        'Internal Storage',
        'Evidence verified and stored off-chain for quick access'
      );

      return {
        success: true,
        mintType: 'soft',
        evidenceId,
        fileHash: mapping.fileHash,
        verificationUrl: `https://storage.chitty.cc/verify/${evidenceId}`,
        message: 'Evidence soft minted successfully (off-chain)',
        gasCost: 0,
        reversible: true
      };

    } catch (error) {
      console.error('Soft minting failed:', error);
      throw new Error(`Soft minting failed: ${error.message}`);
    }
  }

  /**
   * Hard Mint (On-Chain)
   * Permanent blockchain recording with gas costs
   * For critical evidence requiring immutable proof
   */
  async hardMint(evidenceId, blockchainData = {}) {
    try {
      // Get existing evidence mapping
      const mappingKey = `evidence:${evidenceId}`;
      const existingMapping = await this.cache.get(mappingKey);

      if (!existingMapping) {
        throw new Error(`Evidence not found: ${evidenceId}`);
      }

      const mapping = JSON.parse(existingMapping);

      // Check if already soft minted (required before hard minting)
      const softMintKey = `soft-mint:${evidenceId}`;
      const softMintRecord = await this.cache.get(softMintKey);

      if (!softMintRecord) {
        throw new Error('Evidence must be soft minted before hard minting. Soft mint first for initial verification.');
      }

      // Simulate blockchain transaction (in production, this would be actual blockchain)
      const blockHash = await this.generateBlockHash(evidenceId, 'hard_minted');
      const gasEstimate = this.estimateGasCost(mapping.size || 1000);

      // Create permanent blockchain record
      const hardMintRecord = {
        evidenceId,
        fileHash: mapping.fileHash,
        mintType: 'hard',
        verificationLevel: 'on-chain',
        blockchainData: {
          network: blockchainData.network || 'ChittyChain',
          blockHash,
          transactionHash: `0x${blockHash.substring(0, 64)}`,
          blockNumber: Math.floor(Math.random() * 1000000) + 1000000,
          timestamp: new Date().toISOString(),
          gasUsed: gasEstimate,
          immutable: true,
          contractAddress: blockchainData.contractAddress || 'ChittyLedger Smart Contract'
        },
        legalMetadata: {
          courtJurisdiction: blockchainData.courtJurisdiction || 'Cook County, Illinois',
          caseNumber: blockchainData.caseNumber,
          legalStandard: blockchainData.legalStandard || 'Federal Rules of Evidence',
          criticalEvidence: blockchainData.criticalEvidence || false
        }
      };

      // Store permanently in R2 (simulating blockchain storage)
      const hardMintKey = `blockchain/${evidenceId}/hard-mint.json`;
      await this.storage.put(hardMintKey, JSON.stringify(hardMintRecord), {
        httpMetadata: {
          contentType: 'application/json'
        },
        customMetadata: {
          evidenceId,
          mintType: 'hard',
          blockHash,
          immutable: 'true'
        }
      });

      // Update status to hard minted
      await this.updateChainStatus(evidenceId, 'hard_minted', {
        mintType: 'hard',
        record: hardMintRecord
      });

      // Add immutable custody event
      await this.addCustodyEvent(
        evidenceId,
        'Hard Minted (On-Chain)',
        'ChittyChain Blockchain',
        'Immutable Ledger',
        `Evidence permanently recorded on blockchain. Block: ${hardMintRecord.blockchainData.blockNumber}`
      );

      return {
        success: true,
        mintType: 'hard',
        evidenceId,
        fileHash: mapping.fileHash,
        blockHash,
        transactionHash: hardMintRecord.blockchainData.transactionHash,
        blockNumber: hardMintRecord.blockchainData.blockNumber,
        verificationUrl: `https://explorer.chittychain.com/tx/${hardMintRecord.blockchainData.transactionHash}`,
        message: 'Evidence hard minted successfully (on-chain)',
        gasCost: gasEstimate,
        immutable: true,
        reversible: false
      };

    } catch (error) {
      console.error('Evidence minting failed:', error);
      throw new Error(`Evidence minting failed: ${error.message}`);
    }
  }

  estimateGasCost(fileSize) {
    // Estimate gas based on file size (simplified calculation)
    const baseGas = 21000;
    const dataGas = Math.ceil(fileSize / 32) * 68; // 68 gas per 32 bytes
    const totalGas = baseGas + dataGas;
    const gasPrice = 0.00002; // Simplified gas price in ETH
    return {
      gas: totalGas,
      estimatedCost: totalGas * gasPrice,
      currency: 'ETH'
    };
  }

  async checkMintingEligibility(evidenceId) {
    // Check if evidence is eligible for hard minting
    const mappingKey = `evidence:${evidenceId}`;
    const mapping = await this.cache.get(mappingKey);

    if (!mapping) {
      return { eligible: false, reason: 'Evidence not found' };
    }

    const parsed = JSON.parse(mapping);
    const softMintKey = `soft-mint:${evidenceId}`;
    const softMintRecord = await this.cache.get(softMintKey);

    return {
      eligible: true,
      currentStatus: parsed.chainStatus,
      softMinted: !!softMintRecord,
      canHardMint: !!softMintRecord && parsed.chainStatus !== 'hard_minted',
      fileHash: parsed.fileHash,
      size: parsed.size || 0
    };
  }

  /**
   * Chain of Custody Tracking
   * Creates immutable custody chain with blockchain verification
   */
  async addCustodyEvent(evidenceId, action, performedBy, location, notes) {
    const custodyEvent = {
      id: crypto.randomUUID(),
      evidenceId,
      action,
      performedBy,
      location,
      notes,
      timestamp: new Date().toISOString(),
      blockHash: await this.generateBlockHash(evidenceId, action)
    };

    // Store in custody chain
    const custodyKey = `custody:${evidenceId}`;
    const existingCustody = await this.cache.get(custodyKey);
    const custodyChain = existingCustody ? JSON.parse(existingCustody) : [];

    custodyChain.push(custodyEvent);
    await this.cache.put(custodyKey, JSON.stringify(custodyChain));

    // Update Notion with custody event
    await this.addNotionCustodyEntry(evidenceId, custodyEvent);

    return custodyEvent;
  }

  /**
   * Notion Database Integration Methods
   */
  async updateNotionEvidenceStatus(evidenceId, status, metadata) {
    const response = await fetch(`https://api.notion.com/v1/databases/${this.evidenceDbId}/query`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.notionToken}`,
        'Content-Type': 'application/json',
        'Notion-Version': '2022-06-28'
      },
      body: JSON.stringify({
        filter: {
          property: 'Evidence ID',
          rich_text: {
            equals: evidenceId
          }
        }
      })
    });

    const searchResults = await response.json();

    if (searchResults.results.length === 0) {
      throw new Error(`Evidence not found in Notion: ${evidenceId}`);
    }

    const pageId = searchResults.results[0].id;

    // Update the status
    await fetch(`https://api.notion.com/v1/pages/${pageId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${this.notionToken}`,
        'Content-Type': 'application/json',
        'Notion-Version': '2022-06-28'
      },
      body: JSON.stringify({
        properties: {
          'Chain Status': {
            select: {
              name: status.charAt(0).toUpperCase() + status.slice(1)
            }
          },
          'Last Updated': {
            date: {
              start: new Date().toISOString()
            }
          }
        }
      })
    });
  }

  async syncAIMetadataToNotion(evidenceId, aiMetadata) {
    // Find evidence page in Notion
    const response = await fetch(`https://api.notion.com/v1/databases/${this.evidenceDbId}/query`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.notionToken}`,
        'Content-Type': 'application/json',
        'Notion-Version': '2022-06-28'
      },
      body: JSON.stringify({
        filter: {
          property: 'Evidence ID',
          rich_text: { equals: evidenceId }
        }
      })
    });

    const searchResults = await response.json();

    if (searchResults.results.length > 0) {
      const pageId = searchResults.results[0].id;

      // Update with AI metadata
      await fetch(`https://api.notion.com/v1/pages/${pageId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${this.notionToken}`,
          'Content-Type': 'application/json',
          'Notion-Version': '2022-06-28'
        },
        body: JSON.stringify({
          properties: {
            'Evidence Type': {
              select: { name: aiMetadata.evidenceType }
            },
            'Confidence Score': {
              number: aiMetadata.confidenceScore
            },
            'AI Processed': {
              checkbox: true
            },
            'AI Analysis': {
              rich_text: [{
                text: {
                  content: JSON.stringify(aiMetadata, null, 2).substring(0, 2000)
                }
              }]
            }
          }
        })
      });
    }
  }

  /**
   * Utility Methods
   */
  detectContentType(fileName) {
    const ext = fileName.split('.').pop().toLowerCase();
    const mimeTypes = {
      'pdf': 'application/pdf',
      'doc': 'application/msword',
      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'png': 'image/png',
      'txt': 'text/plain'
    };
    return mimeTypes[ext] || 'application/octet-stream';
  }

  async extractTextFromFile(buffer, contentType) {
    // Simple text extraction - in production would use more sophisticated parsers
    if (contentType.includes('text/plain')) {
      return new TextDecoder().decode(buffer);
    }
    // For other types, return truncated content for now
    return new TextDecoder().decode(buffer.slice(0, 1000));
  }

  extractEvidenceType(aiResponse) {
    // Parse AI response for evidence type
    const types = ['Document', 'Image', 'Communication', 'Financial Record', 'Legal Filing', 'Physical Evidence'];
    for (const type of types) {
      if (aiResponse.toLowerCase().includes(type.toLowerCase())) {
        return type;
      }
    }
    return 'Document';
  }

  extractConfidenceScore(aiResponse) {
    const match = aiResponse.match(/confidence[:\s]+(\d+)/i);
    return match ? parseInt(match[1]) : 75;
  }

  extractLegalFacts(aiResponse) {
    // Extract key facts from AI response
    const factMatch = aiResponse.match(/facts?[:\s]+(.*?)(?=\n\n|\n[A-Z]|$)/is);
    return factMatch ? factMatch[1].trim() : 'AI analysis pending';
  }

  extractRelevanceAssessment(aiResponse) {
    const relevanceMatch = aiResponse.match(/relevance[:\s]+(.*?)(?=\n\n|\n[A-Z]|$)/is);
    return relevanceMatch ? relevanceMatch[1].trim() : 'Assessment pending';
  }

  async generateBlockHash(evidenceId, action) {
    const data = `${evidenceId}:${action}:${Date.now()}`;
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(data));
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  async logAuditEvent(eventType, data) {
    const auditKey = `audit:${Date.now()}:${crypto.randomUUID()}`;
    const auditEvent = {
      eventType,
      timestamp: new Date().toISOString(),
      data
    };

    await this.cache.put(auditKey, JSON.stringify(auditEvent));
  }
}

/**
 * Handler for ChittyLedger Integration API
 */
export async function handleChittyLedgerIntegration(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const path = url.pathname;

  const integration = new ChittyLedgerIntegration(env);

  try {
    if (path === '/health') {
      return new Response(JSON.stringify({
        status: 'healthy',
        service: 'ChittyLedger Integration',
        features: [
          'Evidence ID → File Hash Mapping',
          'Chain Status Integration',
          'AI Processing Bridge',
          'Chain of Custody Tracking'
        ],
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (request.method === 'POST' && path === '/evidence/upload') {
      const formData = await request.formData();
      const file = formData.get('file');
      const evidenceId = formData.get('evidenceId');

      if (!file || !evidenceId) {
        return new Response(JSON.stringify({
          error: 'Missing file or evidenceId'
        }), { status: 400, headers: { 'Content-Type': 'application/json' } });
      }

      const fileBuffer = await file.arrayBuffer();
      const result = await integration.uploadEvidenceFile(
        fileBuffer,
        file.name,
        evidenceId
      );

      // Process with AI
      const aiMetadata = await integration.processEvidenceWithAI(evidenceId, result.fileHash);

      // Add initial custody event
      await integration.addCustodyEvent(
        evidenceId,
        'Evidence Uploaded',
        'System',
        'ChittyOS-Data',
        'File uploaded and processed with AI analysis'
      );

      return new Response(JSON.stringify({
        ...result,
        aiMetadata,
        message: 'Evidence uploaded and processed successfully'
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (request.method === 'POST' && path === '/evidence/status') {
      const { evidenceId, status, metadata } = await request.json();

      const result = await integration.updateChainStatus(evidenceId, status, metadata);

      return new Response(JSON.stringify(result), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (request.method === 'POST' && path === '/evidence/soft-mint') {
      const { evidenceId, metadata } = await request.json();

      if (!evidenceId) {
        return new Response(JSON.stringify({
          error: 'Missing evidenceId'
        }), { status: 400, headers: { 'Content-Type': 'application/json' } });
      }

      const result = await integration.softMint(evidenceId, metadata);

      return new Response(JSON.stringify(result), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (request.method === 'POST' && path === '/evidence/hard-mint') {
      const { evidenceId, blockchainData } = await request.json();

      if (!evidenceId) {
        return new Response(JSON.stringify({
          error: 'Missing evidenceId'
        }), { status: 400, headers: { 'Content-Type': 'application/json' } });
      }

      const result = await integration.hardMint(evidenceId, blockchainData);

      return new Response(JSON.stringify(result), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (request.method === 'GET' && path === '/evidence/mint-status') {
      const url = new URL(request.url);
      const evidenceId = url.searchParams.get('evidenceId');

      if (!evidenceId) {
        return new Response(JSON.stringify({
          error: 'Missing evidenceId parameter'
        }), { status: 400, headers: { 'Content-Type': 'application/json' } });
      }

      const eligibility = await integration.checkMintingEligibility(evidenceId);

      return new Response(JSON.stringify(eligibility), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (request.method === 'GET' && path.startsWith('/evidence/')) {
      const evidenceId = path.split('/')[2];
      const mappingKey = `evidence:${evidenceId}`;
      const mapping = await integration.cache.get(mappingKey);

      if (!mapping) {
        return new Response(JSON.stringify({
          error: 'Evidence not found'
        }), { status: 404, headers: { 'Content-Type': 'application/json' } });
      }

      return new Response(mapping, {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    return new Response(JSON.stringify({
      error: 'Endpoint not found',
      availableEndpoints: [
        'POST /evidence/upload - Upload evidence files',
        'POST /evidence/status - Update evidence status',
        'POST /evidence/soft-mint - Soft mint (off-chain verification)',
        'POST /evidence/hard-mint - Hard mint (on-chain blockchain)',
        'GET /evidence/mint-status?evidenceId={id} - Check minting eligibility',
        'GET /evidence/{id} - Get evidence details'
      ]
    }), {
      status: 404,
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('ChittyLedger Integration Error:', error);
    return new Response(JSON.stringify({
      error: 'Integration Error',
      message: error.message
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}