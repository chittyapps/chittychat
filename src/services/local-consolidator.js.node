/**
 * ChittyChat Local Consolidator Service
 * Scans and consolidates Claude Code auto-generated session files
 *
 * Architecture:
 * - Reads existing ~/.claude/projects/<project>/*.jsonl files (auto-generated by Claude)
 * - Reads existing ~/.claude/tasks/ files (if present)
 * - Consolidates todos, context, file operations across multiple sessions
 * - Does NOT create new files in ~/.claude/ - only reads and consolidates
 * - Syncs consolidated state to GitHub chittychat-data repo
 */

import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';
import { createReadStream } from 'fs';
import { createInterface } from 'readline';

/**
 * Local Consolidator - manages local Claude session file consolidation
 */
export class LocalConsolidator {
  constructor() {
    this.homeDir = os.homedir();
    this.claudeProjectsDir = path.join(this.homeDir, '.claude', 'projects');
    this.claudeTasksDir = path.join(this.homeDir, '.claude', 'tasks');
  }

  /**
   * Get all project directories from ~/.claude/projects/
   */
  async getProjectDirectories() {
    try {
      const entries = await fs.readdir(this.claudeProjectsDir, { withFileTypes: true });
      return entries
        .filter((entry) => entry.isDirectory())
        .map((entry) => ({
          name: entry.name,
          path: path.join(this.claudeProjectsDir, entry.name),
        }));
    } catch (error) {
      console.error('Error reading Claude projects directory:', error);
      return [];
    }
  }

  /**
   * Get all session files for a project
   */
  async getSessionFiles(projectPath) {
    try {
      const files = await fs.readdir(projectPath);
      return files
        .filter((file) => file.endsWith('.jsonl'))
        .map((file) => path.join(projectPath, file));
    } catch (error) {
      console.error('Error reading session files:', error);
      return [];
    }
  }

  /**
   * Parse a JSONL session file
   * Returns array of parsed JSON objects
   */
  async parseSessionFile(filePath) {
    const lines = [];

    try {
      const fileStream = createReadStream(filePath);
      const rl = createInterface({
        input: fileStream,
        crlfDelay: Infinity,
      });

      for await (const line of rl) {
        if (line.trim()) {
          try {
            lines.push(JSON.parse(line));
          } catch (parseError) {
            console.warn(`Failed to parse line in ${filePath}:`, parseError);
          }
        }
      }
    } catch (error) {
      console.error(`Error reading session file ${filePath}:`, error);
    }

    return lines;
  }

  /**
   * Extract todos from session data
   */
  extractTodos(sessionData) {
    const todos = [];

    for (const entry of sessionData) {
      // Look for todo-related entries
      if (entry.type === 'tool_use' && entry.content) {
        // Check if this is a TodoWrite tool call
        if (entry.content.name === 'TodoWrite' && entry.content.input?.todos) {
          todos.push({
            timestamp: entry.timestamp || new Date().toISOString(),
            todos: entry.content.input.todos,
            sessionId: entry.sessionId,
          });
        }
      }

      // Also check for assistant messages mentioning todos
      if (entry.type === 'assistant' && entry.content) {
        const content =
          typeof entry.content === 'string' ? entry.content : JSON.stringify(entry.content);
        if (content.includes('todo') || content.includes('task')) {
          // Extract todo-like patterns
          const todoPatterns = content.match(/[-•]\s*(.+)/g);
          if (todoPatterns) {
            todos.push({
              timestamp: entry.timestamp || new Date().toISOString(),
              extractedTodos: todoPatterns.map((t) => t.replace(/^[-•]\s*/, '').trim()),
              sessionId: entry.sessionId,
              type: 'extracted',
            });
          }
        }
      }
    }

    return todos;
  }

  /**
   * Extract file operations from session data
   */
  extractFileOperations(sessionData) {
    const operations = [];

    for (const entry of sessionData) {
      if (entry.type === 'tool_use' && entry.content) {
        const toolName = entry.content.name;

        if (['Read', 'Write', 'Edit', 'Glob', 'Grep'].includes(toolName)) {
          operations.push({
            timestamp: entry.timestamp || new Date().toISOString(),
            tool: toolName,
            input: entry.content.input,
            sessionId: entry.sessionId,
          });
        }
      }
    }

    return operations;
  }

  /**
   * Extract conversation context from session data
   */
  extractContext(sessionData) {
    const context = {
      userMessages: [],
      assistantResponses: [],
      topics: [],
    };

    for (const entry of sessionData) {
      if (entry.type === 'user') {
        context.userMessages.push({
          timestamp: entry.timestamp,
          content: entry.content,
        });
      } else if (entry.type === 'assistant') {
        context.assistantResponses.push({
          timestamp: entry.timestamp,
          content:
            typeof entry.content === 'string'
              ? entry.content.substring(0, 200)
              : 'Non-text response',
        });
      }
    }

    // Extract topics (simple keyword extraction)
    const allText = [
      ...context.userMessages.map((m) => m.content),
      ...context.assistantResponses.map((m) => m.content),
    ].join(' ');

    // Simple topic extraction based on common patterns
    const topicPatterns = [
      /working on (.+?)[\.\,\n]/gi,
      /implement (.+?)[\.\,\n]/gi,
      /create (.+?)[\.\,\n]/gi,
      /fix (.+?)[\.\,\n]/gi,
    ];

    for (const pattern of topicPatterns) {
      const matches = allText.matchAll(pattern);
      for (const match of matches) {
        if (match[1] && match[1].length < 100) {
          context.topics.push(match[1].trim());
        }
      }
    }

    return context;
  }

  /**
   * Consolidate all sessions for a project
   */
  async consolidateProject(projectPath, projectName) {
    const sessionFiles = await this.getSessionFiles(projectPath);

    if (sessionFiles.length === 0) {
      return null;
    }

    const allTodos = [];
    const allFileOperations = [];
    const allContexts = [];
    const sessionMetadata = [];

    // Process each session file
    for (const sessionFile of sessionFiles) {
      const sessionData = await this.parseSessionFile(sessionFile);
      const sessionId = path.basename(sessionFile, '.jsonl');

      // Get file stats for session metadata
      const stats = await fs.stat(sessionFile);

      sessionMetadata.push({
        sessionId,
        filePath: sessionFile,
        created: stats.birthtime,
        modified: stats.mtime,
        size: stats.size,
        entryCount: sessionData.length,
      });

      // Extract information
      const todos = this.extractTodos(sessionData);
      const fileOps = this.extractFileOperations(sessionData);
      const context = this.extractContext(sessionData);

      allTodos.push(...todos);
      allFileOperations.push(...fileOps);
      allContexts.push({ sessionId, context });
    }

    // Consolidate todos (remove duplicates, keep latest)
    const consolidatedTodos = this.deduplicateTodos(allTodos);

    // Consolidate file operations (keep unique paths)
    const consolidatedFiles = this.consolidateFileOperations(allFileOperations);

    // Build consolidated state
    return {
      projectName,
      projectPath,
      totalSessions: sessionFiles.length,
      sessions: sessionMetadata,
      consolidatedTodos,
      filesWorked: consolidatedFiles,
      contexts: allContexts,
      lastActivity: sessionMetadata.reduce(
        (latest, s) => (s.modified > latest ? s.modified : latest),
        new Date(0)
      ),
      consolidatedAt: new Date().toISOString(),
    };
  }

  /**
   * Deduplicate todos keeping latest version
   */
  deduplicateTodos(todos) {
    const todoMap = new Map();

    for (const todoEntry of todos) {
      if (todoEntry.todos && Array.isArray(todoEntry.todos)) {
        for (const todo of todoEntry.todos) {
          const key = todo.content || JSON.stringify(todo);

          if (
            !todoMap.has(key) ||
            new Date(todoEntry.timestamp) > new Date(todoMap.get(key).timestamp)
          ) {
            todoMap.set(key, {
              ...todo,
              timestamp: todoEntry.timestamp,
              sessionId: todoEntry.sessionId,
            });
          }
        }
      }
    }

    return Array.from(todoMap.values());
  }

  /**
   * Consolidate file operations to unique file list
   */
  consolidateFileOperations(operations) {
    const fileMap = new Map();

    for (const op of operations) {
      const filePath = op.input?.file_path || op.input?.path || op.input?.pattern;

      if (filePath) {
        if (!fileMap.has(filePath)) {
          fileMap.set(filePath, {
            path: filePath,
            operations: [],
          });
        }

        fileMap.get(filePath).operations.push({
          tool: op.tool,
          timestamp: op.timestamp,
          sessionId: op.sessionId,
        });
      }
    }

    return Array.from(fileMap.values()).map((file) => ({
      ...file,
      lastOperation: file.operations.reduce((latest, op) =>
        new Date(op.timestamp) > new Date(latest.timestamp) ? op : latest
      ),
    }));
  }

  /**
   * Consolidate all projects
   */
  async consolidateAllProjects() {
    const projects = await this.getProjectDirectories();
    const consolidated = [];

    for (const project of projects) {
      const result = await this.consolidateProject(project.path, project.name);
      if (result) {
        consolidated.push(result);
      }
    }

    return {
      projects: consolidated,
      totalProjects: consolidated.length,
      consolidatedAt: new Date().toISOString(),
    };
  }

  /**
   * Get consolidated state for a specific project
   */
  async getProjectConsolidatedState(projectName) {
    const projectPath = path.join(this.claudeProjectsDir, projectName);

    try {
      await fs.access(projectPath);
      return await this.consolidateProject(projectPath, projectName);
    } catch (error) {
      console.error(`Project ${projectName} not found:`, error);
      return null;
    }
  }

  /**
   * Check if a project has been initialized (has session files)
   */
  async isProjectInitialized(projectName) {
    const projectPath = path.join(this.claudeProjectsDir, projectName);

    try {
      const sessionFiles = await this.getSessionFiles(projectPath);
      return sessionFiles.length > 0;
    } catch (error) {
      return false;
    }
  }

  /**
   * Archive old session files
   * Moves individual session files to .archive subdirectory
   */
  async archiveSessionFiles(projectPath, sessionFiles) {
    const archiveDir = path.join(projectPath, '.archive');

    try {
      // Create archive directory if it doesn't exist
      await fs.mkdir(archiveDir, { recursive: true });

      const archived = [];

      for (const sessionFile of sessionFiles) {
        const fileName = path.basename(sessionFile);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const archiveName = `${timestamp}_${fileName}`;
        const archivePath = path.join(archiveDir, archiveName);

        // Move file to archive
        await fs.rename(sessionFile, archivePath);
        archived.push({
          original: sessionFile,
          archived: archivePath,
        });
      }

      return { success: true, archived, count: archived.length };
    } catch (error) {
      console.error('Error archiving session files:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Merge multiple session files into a single consolidated file
   * Combines all session data, removes duplicates, merges todos
   */
  async mergeSessionFiles(projectPath, sessionFiles, options = {}) {
    try {
      const allEntries = [];
      const preservePatterns = options.preservePatterns || [];

      // Parse all session files
      for (const sessionFile of sessionFiles) {
        const sessionData = await this.parseSessionFile(sessionFile);
        allEntries.push(...sessionData);
      }

      // Sort by timestamp
      allEntries.sort((a, b) => {
        const timeA = new Date(a.timestamp || 0);
        const timeB = new Date(b.timestamp || 0);
        return timeA - timeB;
      });

      // Deduplicate entries (keep unique based on content hash)
      const seen = new Set();
      const uniqueEntries = [];

      for (const entry of allEntries) {
        // Check if entry matches preservation patterns
        const shouldPreserve = preservePatterns.some((pattern) => {
          const entryStr = JSON.stringify(entry);
          return entryStr.includes(pattern);
        });

        // Create hash of entry (excluding timestamp for comparison)
        const { timestamp, ...entryWithoutTime } = entry;
        const hash = JSON.stringify(entryWithoutTime);

        // Always keep preserved entries, even if duplicate
        if (shouldPreserve) {
          uniqueEntries.push({ ...entry, preserved: true });
        } else if (!seen.has(hash)) {
          seen.add(hash);
          uniqueEntries.push(entry);
        }
      }

      return uniqueEntries;
    } catch (error) {
      console.error('Error merging session files:', error);
      return [];
    }
  }

  /**
   * Write consolidated session file
   * Writes merged session data to a new consolidated .jsonl file
   */
  async writeConsolidatedFile(projectPath, mergedData) {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const consolidatedFileName = `consolidated_${timestamp}.jsonl`;
      const consolidatedPath = path.join(projectPath, consolidatedFileName);

      // Write JSONL format (one JSON object per line)
      const lines = mergedData.map((entry) => JSON.stringify(entry)).join('\n');
      await fs.writeFile(consolidatedPath, lines + '\n', 'utf-8');

      return {
        success: true,
        filePath: consolidatedPath,
        entryCount: mergedData.length,
      };
    } catch (error) {
      console.error('Error writing consolidated file:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Sync unified todos back to individual session todo files
   * Keeps parallel sessions in sync with a unified todo list
   */
  async syncUnifiedTodos(projectPath, unifiedTodos) {
    try {
      // Create or update unified todos file
      const todosPath = path.join(projectPath, '.unified-todos.json');
      await fs.writeFile(todosPath, JSON.stringify(unifiedTodos, null, 2), 'utf-8');

      return {
        success: true,
        todosPath,
        todoCount: unifiedTodos.length,
      };
    } catch (error) {
      console.error('Error syncing unified todos:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Load unified todos for active session
   * Used when starting a session to get latest todo state
   */
  async loadUnifiedTodos(projectPath) {
    try {
      const todosPath = path.join(projectPath, '.unified-todos.json');
      const content = await fs.readFile(todosPath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      // File doesn't exist yet, return empty array
      if (error.code === 'ENOENT') {
        return [];
      }
      console.error('Error loading unified todos:', error);
      return [];
    }
  }

  /**
   * Consolidate and merge project session files
   * Main orchestration method: reads, merges, archives, writes
   */
  async consolidateAndMerge(projectName, options = {}) {
    const projectPath = path.join(this.claudeProjectsDir, projectName);

    try {
      // Get all session files
      const sessionFiles = await this.getSessionFiles(projectPath);

      if (sessionFiles.length === 0) {
        return { success: false, error: 'No session files found' };
      }

      // Skip if only one file (already consolidated or only one session)
      if (sessionFiles.length === 1) {
        return {
          success: true,
          message: 'Only one session file, no consolidation needed',
          sessionFiles: sessionFiles.length,
        };
      }

      // Get consolidated state first (for GitHub sync)
      const consolidatedState = await this.consolidateProject(projectPath, projectName);

      // Merge session files with preservation hints
      const mergedData = await this.mergeSessionFiles(projectPath, sessionFiles, options);

      if (mergedData.length === 0) {
        return { success: false, error: 'Failed to merge session files' };
      }

      // Write consolidated file with compaction metadata
      const writeResult = await this.writeConsolidatedFile(projectPath, mergedData, {
        compactionGuidance: options.compactionGuidance,
        preservePatterns: options.preservePatterns,
      });

      if (!writeResult.success) {
        return writeResult;
      }

      // Archive old session files
      const archiveResult = await this.archiveSessionFiles(projectPath, sessionFiles);

      return {
        success: true,
        projectName,
        projectPath,
        consolidated: writeResult,
        archived: archiveResult,
        consolidatedState: {
          ...consolidatedState,
          compactionGuidance: options.compactionGuidance || null,
          preservedPatterns: options.preservePatterns || [],
        },
        originalFiles: sessionFiles.length,
        mergedEntries: mergedData.length,
      };
    } catch (error) {
      console.error('Error in consolidateAndMerge:', error);
      return { success: false, error: error.message };
    }
  }
}

/**
 * Handle local consolidation requests (for Worker integration)
 */
export async function handleLocalConsolidation(context) {
  const { request } = context;
  const url = new URL(request.url);
  const pathname = url.pathname;

  const consolidator = new LocalConsolidator();

  // Health check
  if (pathname === '/health') {
    return new Response(
      JSON.stringify({
        status: 'healthy',
        service: 'ChittyChat Local Consolidator',
        version: '1.0.0',
        features: [
          'session-consolidation',
          'todo-extraction',
          'file-tracking',
          'session-merging',
          'file-archiving',
        ],
      }),
      { headers: { 'Content-Type': 'application/json' } }
    );
  }

  try {
    const method = request.method;

    // GET /api/consolidate/all - Consolidate all projects
    if (method === 'GET' && pathname === '/api/consolidate/all') {
      const result = await consolidator.consolidateAllProjects();
      return new Response(JSON.stringify(result), {
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // GET /api/consolidate/:projectName - Consolidate specific project
    if (method === 'GET' && pathname.match(/^\/api\/consolidate\/(.+)$/)) {
      const projectName = decodeURIComponent(pathname.split('/').pop());
      const result = await consolidator.getProjectConsolidatedState(projectName);

      if (result) {
        return new Response(JSON.stringify(result), {
          headers: { 'Content-Type': 'application/json' },
        });
      } else {
        return new Response(JSON.stringify({ error: 'Project not found or not initialized' }), {
          status: 404,
          headers: { 'Content-Type': 'application/json' },
        });
      }
    }

    // GET /api/projects - List all initialized projects
    if (method === 'GET' && pathname === '/api/projects') {
      const projects = await consolidator.getProjectDirectories();
      const initialized = [];

      for (const project of projects) {
        const isInit = await consolidator.isProjectInitialized(project.name);
        if (isInit) {
          initialized.push(project);
        }
      }

      return new Response(JSON.stringify({ projects: initialized, count: initialized.length }), {
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // POST /api/merge/:projectName - Merge and archive session files
    if (method === 'POST' && pathname.match(/^\/api\/merge\/(.+)$/)) {
      const projectName = decodeURIComponent(pathname.split('/').pop());
      const result = await consolidator.consolidateAndMerge(projectName);

      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Not found
    return new Response(
      JSON.stringify({
        error: 'Not Found',
        message: 'Local consolidation endpoint not found',
        availableEndpoints: [
          'GET /api/consolidate/all',
          'GET /api/consolidate/:projectName',
          'GET /api/projects',
          'POST /api/merge/:projectName',
        ],
      }),
      { status: 404, headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({
        error: 'Internal Error',
        message: error.message,
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
