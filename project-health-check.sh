#!/bin/bash

# ChittyOS Project Health Check
# Comprehensive automated analysis without prompts

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

# Score tracking
TOTAL_CHECKS=0
PASSED_CHECKS=0
CRITICAL_ISSUES=()
WARNINGS=()
FIXED_ITEMS=()

# Project info
PROJECT_PATH=$(pwd)
PROJECT_NAME=$(basename "$PROJECT_PATH")

echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
echo -e "${CYAN}${BOLD}   CHITTYOS PROJECT HEALTH CHECK${RESET}"
echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
echo -e "Project: ${BOLD}$PROJECT_NAME${RESET}"
echo -e "Path: $PROJECT_PATH"
echo -e "Time: $(date '+%Y-%m-%d %H:%M:%S')"
echo ""

# Function to track checks
check() {
    local status=$1
    local message=$2
    ((TOTAL_CHECKS++))

    if [ "$status" = "pass" ]; then
        echo -e "  ${GREEN}âœ“${RESET} $message"
        ((PASSED_CHECKS++))
    elif [ "$status" = "warn" ]; then
        echo -e "  ${YELLOW}âš ${RESET} $message"
        WARNINGS+=("$message")
    elif [ "$status" = "fail" ]; then
        echo -e "  ${RED}âœ—${RESET} $message"
        CRITICAL_ISSUES+=("$message")
    elif [ "$status" = "fixed" ]; then
        echo -e "  ${GREEN}âœ“${RESET} ${BOLD}[FIXED]${RESET} $message"
        ((PASSED_CHECKS++))
        FIXED_ITEMS+=("$message")
    fi
}

# 1. GIT REPOSITORY CHECK
echo -e "${BOLD}1. GIT REPOSITORY${RESET}"
if [ -d ".git" ]; then
    check "pass" "Git repository initialized"

    # Check branch
    BRANCH=$(git branch --show-current 2>/dev/null)
    if [ -n "$BRANCH" ]; then
        check "pass" "Current branch: $BRANCH"
    fi

    # Check uncommitted changes
    UNCOMMITTED=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$UNCOMMITTED" -eq 0 ]; then
        check "pass" "Working tree clean"
    elif [ "$UNCOMMITTED" -lt 10 ]; then
        check "warn" "$UNCOMMITTED uncommitted changes"
    else
        check "fail" "$UNCOMMITTED uncommitted changes (high risk)"
    fi

    # Check for merge conflicts
    if git diff --name-only --diff-filter=U 2>/dev/null | grep -q .; then
        check "fail" "MERGE CONFLICTS DETECTED"
    fi
else
    # Auto-fix: Initialize git
    git init >/dev/null 2>&1
    check "fixed" "Initialized git repository"
fi
echo ""

# 2. CHITTYID INTEGRATION
echo -e "${BOLD}2. CHITTYID INTEGRATION${RESET}"
CHITTYID_OK=false

# Check for token
if [ -f ".env" ] && grep -q "CHITTY_ID_TOKEN\|CHITTYID_TOKEN" .env 2>/dev/null; then
    check "pass" "ChittyID token configured"
    CHITTYID_OK=true
else
    check "fail" "No ChittyID token found"
fi

# Check service health
HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://id.chitty.cc/health 2>/dev/null)
if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "404" ]; then
    check "pass" "ChittyID service reachable"
else
    check "warn" "ChittyID service status: $HTTP_CODE"
fi

# Check for bad ID patterns
BAD_ID_COUNT=$(grep -r "uuid\|nanoid\|crypto\.randomUUID" --include="*.js" --include="*.ts" . 2>/dev/null | grep -v node_modules | wc -l | tr -d ' ')
if [ "$BAD_ID_COUNT" -eq 0 ]; then
    check "pass" "No local ID generation found"
else
    check "fail" "$BAD_ID_COUNT instances of local ID generation"
fi
echo ""

# 3. PROJECT STRUCTURE
echo -e "${BOLD}3. PROJECT STRUCTURE${RESET}"

# Check .gitignore
if [ -f ".gitignore" ]; then
    check "pass" ".gitignore present"
else
    # Auto-fix: Create .gitignore
    cat > .gitignore << 'EOF'
node_modules/
.env
.env.local
.wrangler/
dist/
build/
*.log
.DS_Store
coverage/
.vscode/
.idea/
EOF
    check "fixed" "Created .gitignore"
fi

# Check README
if [ -f "README.md" ] || [ -f "readme.md" ]; then
    check "pass" "README present"
else
    check "warn" "No README.md"
fi

# Check CLAUDE.md
if [ -f "CLAUDE.md" ]; then
    check "pass" "CLAUDE.md instructions present"
else
    # Auto-fix: Create CLAUDE.md
    cat > CLAUDE.md << EOF
# CLAUDE.md

This file provides guidance to Claude Code when working with this project.

## Project Overview
$PROJECT_NAME - Part of the ChittyOS ecosystem

## Architecture
- Type: $([ -f "wrangler.toml" ] && echo "Cloudflare Worker" || echo "Node.js Application")
- ChittyID: All IDs must be generated via https://id.chitty.cc

## Development Commands
\`\`\`bash
npm install
npm run dev
npm test
\`\`\`

## Notes
Generated by health check: $(date)
EOF
    check "fixed" "Created CLAUDE.md"
fi

# Check test structure
if [ -d "tests" ] || [ -d "test" ] || [ -d "__tests__" ]; then
    check "pass" "Test directory present"
else
    mkdir -p tests/unit tests/integration
    check "fixed" "Created test structure"
fi
echo ""

# 4. DEPENDENCIES
echo -e "${BOLD}4. DEPENDENCIES${RESET}"

if [ -f "package.json" ]; then
    check "pass" "package.json present"

    # Check if dependencies installed
    if [ -d "node_modules" ]; then
        check "pass" "Dependencies installed"

        # Check if lock file is outdated
        if [ -f "package-lock.json" ] && [ "package-lock.json" -nt "node_modules" ]; then
            check "warn" "Lock file newer than node_modules"
        fi
    else
        # Auto-fix: Install dependencies
        echo -e "  Installing dependencies..."
        npm install --silent 2>/dev/null
        if [ $? -eq 0 ]; then
            check "fixed" "Dependencies installed"
        else
            check "fail" "Failed to install dependencies"
        fi
    fi

    # Check for scripts
    HAS_DEV=$(grep -q '"dev"' package.json && echo "true" || echo "false")
    HAS_START=$(grep -q '"start"' package.json && echo "true" || echo "false")
    HAS_TEST=$(grep -q '"test"' package.json && echo "true" || echo "false")
    HAS_BUILD=$(grep -q '"build"' package.json && echo "true" || echo "false")

    if [ "$HAS_DEV" = "true" ] || [ "$HAS_START" = "true" ]; then
        check "pass" "Dev/start script present"
    else
        # Auto-fix: Add dev script
        if [ -f "wrangler.toml" ] || [ -f "wrangler.optimized.toml" ]; then
            CONFIG_FILE=$([ -f "wrangler.optimized.toml" ] && echo "wrangler.optimized.toml" || echo "wrangler.toml")
            node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json'));
            pkg.scripts = pkg.scripts || {};
            pkg.scripts.dev = 'wrangler dev --config $CONFIG_FILE';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
            " 2>/dev/null
            check "fixed" "Added dev script for Wrangler"
        else
            node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json'));
            pkg.scripts = pkg.scripts || {};
            pkg.scripts.dev = 'node index.js';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
            " 2>/dev/null
            check "fixed" "Added dev script"
        fi
    fi

    if [ "$HAS_TEST" = "false" ]; then
        check "warn" "No test script"
    fi
else
    check "fail" "No package.json found"
fi
echo ""

# 5. ENVIRONMENT CONFIGURATION
echo -e "${BOLD}5. ENVIRONMENT CONFIGURATION${RESET}"

if [ -f ".env" ]; then
    check "pass" ".env file present"

    # Check for sensitive data exposure
    if [ -d ".git" ] && git ls-files --error-unmatch .env 2>/dev/null; then
        check "fail" ".env is tracked by git!"
    fi
else
    check "warn" "No .env file"
fi

if [ -f ".env.example" ] || [ -f ".env.template" ]; then
    check "pass" "Environment template present"
else
    # Auto-fix: Create .env.example
    cat > .env.example << 'EOF'
# ChittyID Service (REQUIRED)
CHITTY_ID_TOKEN=your_token_here

# ChittyOS Integration
CHITTYOS_ACCOUNT_ID=your_account_here
EOF
    check "fixed" "Created .env.example"
fi
echo ""

# 6. CLOUDFLARE WORKERS
echo -e "${BOLD}6. CLOUDFLARE WORKERS${RESET}"

if [ -f "wrangler.toml" ] || [ -f "wrangler.optimized.toml" ]; then
    if [ -f "wrangler.optimized.toml" ]; then
        check "pass" "Optimized Wrangler config present"

        # Check if package.json uses it
        if [ -f "package.json" ] && grep -q "wrangler.optimized.toml" package.json 2>/dev/null; then
            check "pass" "Package.json uses optimized config"
        else
            check "warn" "Package.json not using optimized config"
        fi
    else
        check "pass" "Wrangler config present"
    fi

    # Check for running instances
    WRANGLER_COUNT=$(ps aux | grep "wrangler dev" | grep -v grep | wc -l | tr -d ' ')
    if [ "$WRANGLER_COUNT" -eq 0 ]; then
        check "pass" "No wrangler instances running"
    elif [ "$WRANGLER_COUNT" -eq 1 ]; then
        check "pass" "1 wrangler instance running"
    else
        check "warn" "$WRANGLER_COUNT wrangler instances running"
    fi
else
    ((TOTAL_CHECKS++))  # Not applicable, but don't penalize
fi
echo ""

# 7. SESSION CONFLICTS
echo -e "${BOLD}7. SESSION CONFLICTS${RESET}"

# Check for active Claude sessions
CLAUDE_PIDS=$(ps aux | grep -E "Claude\.app.*Helper" | grep -v grep | wc -l | tr -d ' ')
if [ "$CLAUDE_PIDS" -gt 0 ]; then
    check "pass" "$CLAUDE_PIDS Claude session(s) active"
else
    check "pass" "No active Claude sessions"
fi

# Check for git worktrees
if [ -d ".git" ]; then
    WORKTREE_COUNT=$(git worktree list 2>/dev/null | wc -l | tr -d ' ')
    if [ "$WORKTREE_COUNT" -gt 1 ]; then
        check "pass" "$WORKTREE_COUNT git worktrees configured"
    else
        check "warn" "No git worktrees (consider for multi-session work)"
    fi
fi

# Check cross-session sync
if ps aux | grep -q "start-project-sync" | grep -v grep; then
    check "pass" "Cross-session sync running"
else
    check "warn" "Cross-session sync not running"
fi
echo ""

# 8. CODE QUALITY
echo -e "${BOLD}8. CODE QUALITY${RESET}"

# Check file sizes
LARGE_FILES=$(find . -type f \( -name "*.js" -o -name "*.ts" \) -size +100k 2>/dev/null | wc -l | tr -d ' ')
if [ "$LARGE_FILES" -eq 0 ]; then
    check "pass" "No oversized files"
else
    check "warn" "$LARGE_FILES large files (>100KB)"
fi

# Check for console.logs in production code
if [ -d "src" ]; then
    CONSOLE_LOGS=$(grep -r "console\.log" src --include="*.js" --include="*.ts" 2>/dev/null | wc -l | tr -d ' ')
    if [ "$CONSOLE_LOGS" -eq 0 ]; then
        check "pass" "No console.log statements"
    else
        check "warn" "$CONSOLE_LOGS console.log statements"
    fi
fi

# Check for TODO comments
TODO_COUNT=$(grep -r "TODO\|FIXME\|XXX" --include="*.js" --include="*.ts" --include="*.jsx" --include="*.tsx" . 2>/dev/null | grep -v node_modules | wc -l | tr -d ' ')
if [ "$TODO_COUNT" -eq 0 ]; then
    check "pass" "No TODO comments"
elif [ "$TODO_COUNT" -lt 5 ]; then
    check "warn" "$TODO_COUNT TODO/FIXME comments"
else
    check "fail" "$TODO_COUNT TODO/FIXME comments (high)"
fi
echo ""

# 9. SECURITY
echo -e "${BOLD}9. SECURITY${RESET}"

# Check for exposed secrets
SECRET_PATTERNS=$(grep -r "api[_-]key\|secret\|token\|password" --include="*.js" --include="*.ts" . 2>/dev/null | grep -v node_modules | grep -v ".env" | grep -E "=\s*[\"'][^\"']{20,}" | wc -l | tr -d ' ')
if [ "$SECRET_PATTERNS" -eq 0 ]; then
    check "pass" "No hardcoded secrets detected"
else
    check "fail" "$SECRET_PATTERNS potential hardcoded secrets"
fi

# Check npm audit
if [ -f "package-lock.json" ] && [ -d "node_modules" ]; then
    VULNERABILITIES=$(npm audit --json 2>/dev/null | grep -c '"severity"' || echo "0")
    if [ "$VULNERABILITIES" -eq 0 ]; then
        check "pass" "No known vulnerabilities"
    else
        check "warn" "$VULNERABILITIES npm vulnerabilities"
    fi
fi
echo ""

# 10. DOCUMENTATION
echo -e "${BOLD}10. DOCUMENTATION${RESET}"

# Check for inline documentation
if [ -d "src" ]; then
    JS_FILES=$(find src -name "*.js" -o -name "*.ts" 2>/dev/null | wc -l | tr -d ' ')
    JSDOC_COMMENTS=$(grep -r "/\*\*" src --include="*.js" --include="*.ts" 2>/dev/null | wc -l | tr -d ' ')

    if [ "$JS_FILES" -gt 0 ]; then
        if [ "$JSDOC_COMMENTS" -gt 0 ]; then
            check "pass" "JSDoc comments present"
        else
            check "warn" "No JSDoc comments"
        fi
    fi
fi

# Check for API documentation
if [ -f "openapi.yaml" ] || [ -f "openapi.json" ] || [ -f "swagger.json" ]; then
    check "pass" "API documentation present"
elif [ -f "wrangler.toml" ]; then
    check "warn" "No API documentation"
fi
echo ""

# FINAL REPORT
echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
echo -e "${CYAN}${BOLD}   HEALTH CHECK SUMMARY${RESET}"
echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"

SCORE=$((PASSED_CHECKS * 100 / TOTAL_CHECKS))
GRADE=""
COLOR=""

if [ $SCORE -ge 90 ]; then
    GRADE="A"
    COLOR=$GREEN
elif [ $SCORE -ge 80 ]; then
    GRADE="B"
    COLOR=$GREEN
elif [ $SCORE -ge 70 ]; then
    GRADE="C"
    COLOR=$YELLOW
elif [ $SCORE -ge 60 ]; then
    GRADE="D"
    COLOR=$YELLOW
else
    GRADE="F"
    COLOR=$RED
fi

echo -e "Overall Score: ${COLOR}${BOLD}${SCORE}% (Grade: $GRADE)${RESET}"
echo -e "Checks Passed: ${PASSED_CHECKS}/${TOTAL_CHECKS}"
echo ""

# Show auto-fixes
if [ ${#FIXED_ITEMS[@]} -gt 0 ]; then
    echo -e "${GREEN}${BOLD}âœ… AUTOMATICALLY FIXED (${#FIXED_ITEMS[@]} items):${RESET}"
    for item in "${FIXED_ITEMS[@]}"; do
        echo -e "  â€¢ $item"
    done
    echo ""
fi

# Show critical issues
if [ ${#CRITICAL_ISSUES[@]} -gt 0 ]; then
    echo -e "${RED}${BOLD}ğŸš¨ CRITICAL ISSUES (${#CRITICAL_ISSUES[@]}):${RESET}"
    for issue in "${CRITICAL_ISSUES[@]}"; do
        echo -e "  â€¢ $issue"
    done
    echo ""
fi

# Show warnings
if [ ${#WARNINGS[@]} -gt 0 ]; then
    echo -e "${YELLOW}${BOLD}âš ï¸  WARNINGS (${#WARNINGS[@]}):${RESET}"
    printf '%s\n' "${WARNINGS[@]:0:5}" | while IFS= read -r warning; do
        echo -e "  â€¢ $warning"
    done
    if [ ${#WARNINGS[@]} -gt 5 ]; then
        echo -e "  ... and $((${#WARNINGS[@]} - 5)) more"
    fi
    echo ""
fi

# Recommendations based on score
echo -e "${BOLD}NEXT STEPS:${RESET}"
if [ $SCORE -lt 60 ]; then
    echo "  1. Fix critical issues immediately"
    echo "  2. Run 'npm install' to ensure dependencies"
    echo "  3. Add ChittyID integration"
elif [ $SCORE -lt 80 ]; then
    echo "  1. Address warnings to improve score"
    echo "  2. Consider adding tests"
    echo "  3. Review TODO comments"
else
    echo "  1. Project is healthy!"
    echo "  2. Consider adding more documentation"
    echo "  3. Keep dependencies updated"
fi

echo ""
echo -e "${CYAN}Report generated: $(date '+%H:%M:%S')${RESET}"
echo -e "${CYAN}Run 'project' for interactive fixes${RESET}"